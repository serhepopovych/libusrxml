Simple XML-like format parsing libarary and useful utilities written in awk(1)
==============================================================================

Data format is specific to define traffic control rules for given network
service provider subscriber (called just "user" for simplicity).

This code however can be an example on how to parse XML or similar data using
awk(1) from shell scripts.

Document format
---------------

Document contains multiple user definitions each of which defines interface
user connected, set of IPv4/IPv6 networks/addresses assigned to user, zones
with directions and allocated bandwidth.

Zones, directions and bandwidths are grouped together within pipe data
structure.

  Zones can be "local" for traffic belonging to local networks (e.g.
  country/city IXPs, peering connections, etc), "world" for rest of
  networks and "all" to treat everything equally.

  Directions can be "in" for incoming traffic to user (download), "out"
  for outgoing traffic from user (upload) or "all" to apply for both
  "in" and "out" directions.

  Bandwidth gives allocated bandwidth for direction in zone. It is
  specified in Kbit/s.

Here is typical example of document format library is able to parse:

<user WN2019011501>
	<pipe 1>
		<zone local>
		<dir all>
		<bw 102400Kb>
	</pipe>
	<pipe 2>
		<zone world>
		<dir in>
		<bw 10240Kb>
	</pipe>
	<pipe 3>
		<zone world>
		<dir out>
		<bw 5120Kb>
	</pipe>
	<if eth0.4094>
	<net 203.0.113.130/30>
		<src 203.0.113.129>
		<mac 02:11:22:33:44:55>
	</net>
	<net 192.0.2.128/30>
		<via 203.0.113.130>
	</net>
</user>

This document describes

Library API
-----------

There are three main API functions provided by libusrxml.awk module:

  BEGIN{
      # Prepare parser by initializing internal variables. This should be
      # very first routine called from the library.
      # Usually called from BEGIN{} awk(1) program section.

      h = init_usrxml_parser();
      if (h < 0)
          exit 1;
  }

  {
      # Takes single line of data and parses it to internal data structures.
      # Usually called from main {} awk(1) program section.

      rc = run_usrxml_parser(h, line);
      if (rc != USRXML_E_NONE)
          exit 1;
  }

  END{
      rc = 0;

      # Performs final checks to ensure document parsed correctly.
      # Usually called from END{} awk(1) program section.

      rc += result_usrxml_parser(h);

      # Destroy parser data structures for given handle @.
      # Usually called from END{} awk(1) program section.

      rc += fini_usrxml_parser(h);

      exit rc;
  }

All these functions return zero on success or less than zero on error. One
can use USRXML_errno variable holding integer value representing error code
and special constant-like defines matching these codes to find exact problem:

  #
  # USRXML error codes.
  #
  USRXML_E_NONE   = 0;
  USRXML_E_INVAL  = -1;
  USRXML_E_EMPTY  = -2;
  USRXML_E_DUP    = -3;
  USRXML_E_MISS   = -4;
  USRXML_E_SCOPE  = -50;
  # generic
  USRXML_E_SYNTAX = -100;
  # API
  USRXML_E_HANDLE_INVALID = -201;
  USRXML_E_HANDLE_FULL    = -202;

If document parsed successfuly (i.e. result_usrxml_parser() returns 0) following
data structures become avaiable to the calling code:

  # Number of <user> data structures parsed in document. Each
  # <user> data structure has number starting from zero "userid".
  nusers = USRXML_usernames[h]
  userid = [0 .. nusers - 1]

  # Name from <user {name}> data structure for given "userid".
  username = USRXML_usernames[h,userid]

  # Userid for given name from <user {name}>.
  userid = USRXML_userids[h,username]

  # Space separated list of "userid"s for given "userif".
  USRXML_ifusers[h,userif]

  # Map net, net6, nat, nat6. Used internally for duplicate
  # detection; overlapping networks supported.
  userid = USRXML_nets[h,net]
  userid = USRXML_nets6[h,net6]
  userid = USRXML_nats[h,nat]
  userid = USRXML_nats6[h,nat6]

  # Number of pipes for given "userid". Each <pipe> data
  # structure has index (pipeid) starting from 0 to this number.
  pipeid = USRXML_userpipe[h,userid]
  # Zone name of given pipe for which settings applied.
  USRXML_userpipe[h,userid,pipeid,"zone"]
  # Direction for given zone. Can be "world", "local" or "all".
  USRXML_userpipe[h,userid,pipeid,"dir"]
  # Bandwidth for given zone. Specified in Kbits/s.
  USRXML_userpipe[h,userid,pipeid,"bw"]
  # Queueing discipline name to attach. Default is empty ("") if unspecified.
  USRXML_userpipe[h,userid,pipeid,"qdisc"]
  # Number of queueing discipline options. Each <opts> data
  # structure has index (optid) starting from 0 to this number.
  optid = USRXML_userpipe[h,userid,pipeid,"opts"]
  # Queueing options
  USRXML_userpipe[h,userid,pipeid,"opts",optid]

  # Name of network interface where <user> connected.
  # Can be shared by multiple "userid"s data structures.
  userif = USRXML_userif[h,userid]

  # Number of IPv4 networks for given "userid". Each <net> data
  # structure has index (netid) starting from 0 to this number.
  netid = USRXML_usernets[h,userid]
  # Set of <net>s for given "userid".
  USRXML_usernets[h,userid,netid]
  USRXML_usernets[h,userid,netid,"src"]
  USRXML_usernets[h,userid,netid,"via"]
  USRXML_usernets[h,userid,netid,"mac"]

  # Number of IPv6 networks for given "userid". Each <net6> data
  # structure has index (net6id) starting from 0 to this number.
  net6id = USRXML_usernets6[h,userid]
  # Set of <net6>s for given "userid".
  USRXML_usernets6[h,userid,net6id]
  USRXML_usernets6[h,userid,net6id,"src"]
  USRXML_usernets6[h,userid,net6id,"via"]
  USRXML_usernets6[h,userid,net6id,"mac"]

  # Number of IPv4 networks before SNAT for given "userid". Each <nat> data
  # structure has index (natid) starting from 0 to this number.
  natid = USRXML_usernats[h,userid]
  # Set of <nat4>s for given "userid".
  USRXML_usernats[h,userid,natid]

  # Number of IPv6 networks before SNAT for given "userid". Each <nat6> data
  # structure has index (nat6id) starting from 0 to this number.
  nat6id = USRXML_usernats6[h,userid]
  # Set of <nat6>s for given "userid".
  USRXML_usernats6[h,userid,nat6id]

There is two additional functions defined in the library to print <user>
that can be used only with successfuly parsed document:

  # Use friendly output format with each <tag> placed on their
  # own newline and tabs for indendation.
  rc = print_usrxml_entry(h, userid);
  if (rc != USRXML_E_NONE)
      exit 1;

  # Put everything on single line. This format is useful for machine
  # processing (e.g. search with grep(1)).
  rc = print_usrxml_entry_oneline(h, userid);
  if (rc != USRXML_E_NONE)
      exit 1;

Examples
--------

There is users_xml2lst.awk and users_lst2xml.awk binaries that parse
document and output it with each <user> tag on single line or normal
format.

Assuming you have installed these scripts under /netctl/bin you can
use following command sequence to verify document correctness:

  $ cat >/tmp/usr.xml <<EOF
<user WN2019011502>
	<pipe 1>
		<zone world>
		<dir all>
		<bw 20480Kb>
	</pipe>
	<if eth0.4094>
	<net 203.0.113.97/32>
		<src 203.0.113.1>
		<mac 02:11:22:33:44:55>
	</net>
</user>
EOF

  $ /netctl/bin/users_xml2lst.awk /tmp/usr.xml | \
  /netctl/bin/users_lst2xml.awk

These tools can also be used for document validation from shell.
